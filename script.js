
const DEFAULT_UNIVERSE = ['RELIANCE.NS','TCS.NS','INFY.NS','HDFCBANK.NS','HDFC.NS','ICICIBANK.NS','LT.NS','KOTAKBANK.NS','SBIN.NS','AXISBANK.NS'];
const MAX_SCAN = 300; let cached = {}, lastResults = [], chart = null;
function el(id){ return document.getElementById(id); } function setStatus(s){ el('status').innerText = s; } function fmt(n){ return Number(n).toLocaleString('en-IN',{maximumFractionDigits:2}); }
async function fetchOHLC(symbol, period='6mo', interval='1d'){ const url = `https://query1.finance.yahoo.com/v8/finance/chart/${encodeURIComponent(symbol)}?range=${period}&interval=${interval}`; try{ const r = await fetch(url); if(!r.ok) throw new Error('HTTP ' + r.status); const j = await r.json(); const result = j.chart && j.chart.result && j.chart.result[0]; if(!result) throw new Error('No data'); const ts = result.timestamp || []; const quote = result.indicators && result.indicators.quote && result.indicators.quote[0]; if(!quote) throw new Error('No quote data'); const o = quote.open, h = quote.high, l = quote.low, c = quote.close; const out = []; for(let i=0;i<ts.length;i++){ if(o[i]==null||h[i]==null||l[i]==null||c[i]==null) continue; const d = new Date(ts[i]*1000); out.push({time: d.toISOString().slice(0,10), open:o[i], high:h[i], low:l[i], close:c[i]}); } return out; } catch(err){ console.warn('fetchOHLC error', symbol, err); return null; } }
function closes(series){ return series.map(s=>s.close); }
function sma(series, window){ const c = closes(series); const res=[]; for(let i=0;i<c.length;i++){ const slice=c.slice(Math.max(0,i-window+1),i+1); const avg = slice.reduce((a,b)=>a+b,0)/slice.length; res.push(avg);} return res; }
function rsi(series, period=14){ const c=closes(series); let up=0,down=0; const res=[]; for(let i=0;i<c.length;i++){ if(i==0){ res.push(50); continue;} const d=c[i]-c[i-1]; up=(up*(period-1)+Math.max(0,d))/period; down=(down*(period-1)+Math.max(0,-d))/period; const rs=up/(down||1e-9); res.push(100 - 100/(1+rs)); } return res; }
function emaArr(series, span){ const c=closes(series); const k=2/(span+1); const res=[]; let prev=null; for(let i=0;i<c.length;i++){ if(prev==null){ prev=c[i]; res.push(prev);} else { prev = c[i]*k + prev*(1-k); res.push(prev);} } return res; }
function macd(series){ const fast = emaArr(series,12); const slow = emaArr(series,26); const macd = fast.map((v,i)=> v - slow[i]); const signal = (function(){ const k=2/(9+1); let prev=null; const out=[]; for(let i=0;i<macd.length;i++){ if(prev==null){ prev=macd[i]; out.push(prev);} else{ prev = macd[i]*k + prev*(1-k); out.push(prev);} } return out; })(); const hist = macd.map((v,i)=> v - signal[i]); return {macd, signal, hist}; }
function boll(series, window=20,n=2){ const s = sma(series,window); const c=closes(series); const stds=[]; for(let i=0;i<c.length;i++){ const slice=c.slice(Math.max(0,i-window+1),i+1); const mean=s[i]; const varr = slice.reduce((a,b)=>a+Math.pow(b-mean,2),0)/slice.length; stds.push(Math.sqrt(varr)); } const lower = s.map((v,i)=> v - n*stds[i]); const upper = s.map((v,i)=> v + n*stds[i]); return {lower,mid:s,upper}; }
function analyzeSeries(series, capital=100000, risk_pct=1, target_pct=12){ if(!series || series.length<20) return {error:'insufficient data'}; const last = series[series.length-1].close; const sma20 = sma(series,20).slice(-1)[0]; const sma50 = sma(series,50).slice(-1)[0]; const rsi14 = rsi(series,14).slice(-1)[0]; const m = macd(series); const mac_now = m.macd.slice(-1)[0], mac_sig = m.signal.slice(-1)[0]; const bb = boll(series,20,2); const bb_low = bb.lower.slice(-1)[0], bb_up = bb.upper.slice(-1)[0]; let score=0; const reasons=[]; if(sma50){ if(last > sma50){ score++; reasons.push('Above 50 SMA'); } else { score--; reasons.push('Below 50 SMA'); } } if(rsi14){ if(rsi14<30){ score++; reasons.push('RSI oversold'); } else if(rsi14>70){ score--; reasons.push('RSI overbought'); } else reasons.push(`RSI ${rsi14.toFixed(1)}`); } if(mac_now && mac_sig){ if(mac_now > mac_sig){ score++; reasons.push('MACD bullish'); } else { score--; reasons.push('MACD bearish'); } } if(bb_low && bb_up){ if(last <= bb_low){ score++; reasons.push('Near lower Bollinger'); } else if(last >= bb_up){ score--; reasons.push('Near upper Bollinger'); } else reasons.push('Within Bollinger'); } const rec = score>=2? 'BUY' : (score<=-2? 'SELL' : 'HOLD'); const entry = rec==='BUY'? +(last*0.995).toFixed(2) : last; const stop = +(last*0.95).toFixed(2); const target = +(last*(1+target_pct/100)).toFixed(2); const risk_amount = capital * (risk_pct/100); const per_share_risk = Math.max(1e-3, Math.abs(entry - stop)); const qty = Math.floor(risk_amount / per_share_risk); const pos_value = +(qty * entry).toFixed(2); const expected_profit_pct = +(((target-entry)/entry)*100).toFixed(2); return {last, sma20, sma50, rsi14, mac_now, mac_sig, bb_low, bb_up, score, rec, entry, stop, target, qty, pos_value, expected_profit_pct, reasons}; }
function renderPicks(containerId, picks){ const elc = el(containerId); if(!picks || !picks.length){ elc.innerHTML = '<div class="muted">No picks</div>'; return; } let html = '<table><thead><tr><th>Symbol</th><th>Rec</th><th>Entry</th><th>Target</th><th>Exp%</th></tr></thead><tbody>'; picks.forEach(p=>{ html += `<tr onclick="plotSymbol('${p.symbol}')" style="cursor:pointer"><td>${p.symbol}</td><td>${p.rec}</td><td>₹ ${fmt(p.entry)}</td><td>₹ ${fmt(p.target)}</td><td>${p.expected_profit_pct}%</td></tr>`; }); html += '</tbody></table>'; elc.innerHTML = html; }
async function analyzeUniverse(symbols, options={capital:100000,risk_pct:1}){ setStatus('Scanning...'); el('topIntraday').innerText='Scanning...'; el('topSwing').innerText='Scanning...'; const results = []; const max = Math.min(symbols.length, MAX_SCAN); for(let i=0;i<max;i++){ const sym = symbols[i]; try{ const period = '6mo', interval = '1d'; const series = await fetchOHLC(sym, period, interval); if(!series){ results.push({symbol:sym, error:'no data'}); continue; } cached[sym] = series; const analysis = analyzeSeries(series, options.capital, options.risk_pct, 12); analysis.symbol = sym; results.push(analysis); } catch(err){ results.push({symbol:sym, error:err.message}); } } const ranked = results.filter(r=> !r.error).sort((a,b)=> b.expected_profit_pct - a.expected_profit_pct); const topIntraday = ranked.slice(0,10); const topSwing = ranked.slice(0,10); lastResults = results; renderPicks('topIntraday', topIntraday); renderPicks('topSwing', topSwing); renderAll(results); setStatus('Scan complete'); return results; }
function renderAll(results){ const elAll = el('topSwing'); }
async function plotSymbol(sym){ setStatus('Fetching series for ' + sym); const series = cached[sym] || await fetchOHLC(sym, '6mo', '1d'); if(!series){ el('analysisArea').innerText = 'No series data for ' + sym; return; } cached[sym] = series; const container = el('chartContainer'); container.innerHTML = ''; const chartObj = LightweightCharts.createChart(container, {width: container.clientWidth, height:420, layout:{background:'#ffffff',textColor:'#000000'}}); const candle = chartObj.addCandlestickSeries(); const data = series.map(s=> ({time:s.time, open:s.open, high:s.high, low:s.low, close:s.close})); candle.setData(data); chartObj.timeScale().fitContent(); el('chartTitle').innerText = sym; const analysis = analyzeSeries(series); el('analysisArea').innerHTML = `<pre>${sym} • Recommendation: ${analysis.rec}\nEntry: ₹ ${fmt(analysis.entry)}  Target: ₹ ${fmt(analysis.target)}  Stop: ₹ ${fmt(analysis.stop)}\nQty (risk ${document.getElementById('risk')?document.getElementById('risk').value:'1'}%): ${analysis.qty}\nReasons:\n- ${analysis.reasons.join('\n- ')}</pre>`; setStatus('Chart ready'); }
document.getElementById('analyzeBtn').addEventListener('click', async ()=>{ const user = el('globalSearch').value.trim(); const symbols = user ? user.split(',').map(s=>s.trim()) : DEFAULT_UNIVERSE.slice(); await analyzeUniverse(symbols, {capital: Number(el('capital')?el('capital').value:100000), risk_pct: Number(el('risk')?el('risk').value:1)}); }); document.getElementById('plotBtn').addEventListener('click', ()=>{ const s = document.getElementById('symbolInput').value.trim(); if(!s) return alert('Enter symbol'); plotSymbol(s); }); document.getElementById('addSymbolBtn').addEventListener('click', ()=>{ const s = document.getElementById('symbolInput').value.trim(); if(!s) return alert('Enter symbol'); const cur = el('globalSearch').value ? el('globalSearch').value.split(',').map(x=>x.trim()) : []; if(!cur.includes(s)) cur.unshift(s); el('globalSearch').value = cur.join(','); }); document.getElementById('refreshBtn').addEventListener('click', ()=> location.reload()); setStatus('Ready — enter symbols or click Analyze');
